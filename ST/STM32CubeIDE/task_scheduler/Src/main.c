/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "main.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void task1_handler(void);
void task2_handler(void);
void task3_handler(void);
void task4_handler(void);


void init_systick_timer(uint32_t tick_hz);
__attribute((naked)) void init_scheduler_stack(uint32_t sched_top_of_stack);
void init_task_stack(void);
void enable_processor_faults(void);
__attribute((naked)) void switch_sp_to_psp(void);
uint32_t get_psp_value(void);
void save_psp_value(uint32_t);
void update_next_task(void);
void schedule(void);

void task_delay(uint32_t tick_count);

//uint32_t psp_of_stacks[MAX_TASKS] = {T1_STACK_START,T2_STACK_START,T3_STACK_START,T4_STACK_START};

//uint32_t task_handler[MAX_TASKS];

uint32_t g_tick_count = 0;

uint8_t current_task = 1;	//La tarea1 esta ejecutandose.

typedef struct{
	uint32_t psp_value;
	uint32_t block_count;
	uint8_t current_state;
	void (*task_handler)(void);
}TCB_t;

TCB_t user_tasks[MAX_TASKS];

int main(void)
{
	enable_processor_faults();

	init_scheduler_stack(SCHED_STACK_START);

	//Direcciones de las tareas.
	//task_handler[0] = (uint32_t)task1_handler;
	//task_handler[1] = (uint32_t)task2_handler;
	//task_handler[2] = (uint32_t)task3_handler;
	//task_handler[3] = (uint32_t)task4_handler;

	init_task_stack();

	init_systick_timer(TICK_HZ);

	switch_sp_to_psp();

	task1_handler();

    /* Loop forever */
	for(;;);
}

void idle_task (void){
	while(1);
}

void task1_handler(void){
	while(1){
		printf("Esta es la tarea 1.\n");
	}
}

void task2_handler(void){
	while(1){
		printf("Esta es la tarea 2.\n");
	}
}

void task3_handler(void){
	while(1){
		printf("Esta es la tarea 3.\n");
	}
}

void task4_handler(void){
	while(1){
		printf("Esta es la tarea 4.\n");
	}
}

void init_systick_timer(uint32_t tick_hz){
	uint32_t *pSRVR = (uint32_t*)0xE000E014;
	uint32_t *pSCSR = (uint32_t*)0xE000E010;

	uint32_t count_value = SYSTICK_TIM_CLK/tick_hz;

	//Limpiar el valor de SVR
	*pSRVR &= ~(0x00FFFFFF);

	//Cargar el valor de SVR
	*pSRVR |= count_value;

	//Hacer algunos ajustes
	*pSCSR |= (1 << 1);	//Habilita el pedido de excepcion systick
	*pSCSR |= (1 << 2); //Indica la fuente del clock, en este caso interno

	//Habilita el contador
	*pSCSR |= (1 << 0);
}

__attribute((naked)) void init_scheduler_stack(uint32_t sched_top_of_stack){
	//__asm volatile("mrs MSP,%0": : "r" (sched_top_of_stack) : );
	__asm volatile ("MSR MSP,R3");
	__asm volatile ("BX LR");
}

void init_task_stack(void){
	user_tasks[0].current_state = TASK_READY_STATE;
	user_tasks[1].current_state = TASK_READY_STATE;
	user_tasks[2].current_state = TASK_READY_STATE;
	user_tasks[3].current_state = TASK_READY_STATE;
	user_tasks[4].current_state = TASK_READY_STATE;

	user_tasks[0].psp_value	= IDLE_STACK_START;
	user_tasks[1].psp_value	= T1_STACK_START;
	user_tasks[2].psp_value	= T2_STACK_START;
	user_tasks[3].psp_value	= T3_STACK_START;
	user_tasks[4].psp_value	= T4_STACK_START;

	user_tasks[0].task_handler = idle_task;
	user_tasks[1].task_handler = task1_handler;
	user_tasks[2].task_handler = task2_handler;
	user_tasks[3].task_handler = task3_handler;
	user_tasks[4].task_handler = task4_handler;

	uint32_t *pPSP;
	for(int i = 0; i < MAX_TASKS; i++){
		//pPSP =(uint32_t *) psp_of_stacks[i];

		pPSP = (uint32_t *)user_tasks[i].psp_value;

		pPSP--;	//XPSR
		*pPSP = DUMMY_XPSR; //0x00100000

		pPSP--;//PC
		//*pPSP = task_handler[i];
		*pPSP = (uint32_t) user_tasks[i].task_handler;

		pPSP--;//LR
		*pPSP = 0xFFFFFFFD;

		for(int j = 0 ; j > 0 ; j++){
			pPSP--;//Registros
			*pPSP = 0;
		}

		//psp_of_stacks[i] = (uint32_t)pPSP;
		user_tasks[i].psp_value = (uint32_t)pPSP;
	}
}

void enable_processor_faults(void){
	//Habilitar todas las excepciones configurables como error de uso,
	//error de manejo de memoria y error de bus
	uint32_t *pSHCSR = (uint32_t*)0xE000ED24;

	*pSHCSR |= (1 << 16);	//manejo de memoria
	*pSHCSR |= (1 << 17);	//error de bus
	*pSHCSR |= (1 << 18);	//error de uso
}

//Implementar los manipuladores de errores.
void HardFault_Handler(void){
	printf("Excepción : Hardfault\n");
	while(1);
}

void MemManage_Handler(void){
	printf("Excepción : Manejo de memoria\n");
	while(1);
}

void BusFault_Handler(void){
	printf("Excepción : Error de bus\n");
	while(1);
}

uint32_t get_psp_value(void){
	//return psp_of_stacks[current_task];
	return user_tasks[current_task].psp_value;
}

void save_psp_value(uint32_t current_psp_value){
	//psp_of_stacks[current_task] = current_psp_value;
	user_tasks[current_task].psp_value = current_psp_value;
}

//Round-robin
void update_next_task(void){
	int state = TASK_BLOCKED_STATE;

	for(int i = 0; i < (MAX_TASKS); i++){
		current_task++;
		current_task = current_task % MAX_TASKS;
		state = user_tasks[current_task].current_state;
		if((state == TASK_READY_STATE) && (current_task != 0))
			break;
	}

	if (state != TASK_READY_STATE)
		current_task = 0;
}

__attribute((naked)) void switch_sp_to_psp(void){
	//1. Inicializar el PSP con la dirección de TASK1 stack start

	//Obtener el valor de psp de la tarea actual
	__asm volatile ("PUSH {LR}");	//Preservar LR que contiene la vuelta a un main().
	__asm volatile ("BL get_psp_value");
	__asm volatile ("MSR PSP,R0");	//Inicializar PSP.
	__asm volatile ("POP {LR}");	//Desapila el valor LR

	//2. Cambiar SP a PSP usando el registro de control
	__asm volatile ("MOV R0,#0x02");
	__asm volatile ("MSR CONTROL,R0");
	__asm volatile ("BX LR");
}

void schedule(void){
	uint32_t *pICSR = (uint32_t*)0xE000ED04;
	//Poner pendiente la excepción PendSV
	*pICSR |= (1 << 28);
}



void task_delay(uint32_t tick_count){
	//Deshabilitar interrupciones para evitar condiciones de carrera
	INTERRUPT_DISABLE();

	if(current_task){
		user_tasks[current_task].block_count = g_tick_count + tick_count;
		user_tasks[current_task].current_state = TASK_BLOCKED_STATE;
		schedule();
	}

	//Habilitar interrupciones
	INTERRUPT_ENABLE();
}

__attribute((naked)) void PendSV_Handler(){
	/*Guardar el contexto de la actual tarea*/
	//1. Obtener el valor PSP de la tarea que se esta ejecutando
	__asm volatile ("MRS R0,PSP");
	//2. Usar el valor PSP para almacenar SF2 (R4 a R11)
	__asm volatile ("STMDB R0!,{R4-R11}"); //El signo de exclamación sirve para actualizar la dirección en R0.
	__asm volatile ("PUSH {LR}");
	//3.Salvar el valor actual de PSP
	__asm volatile ("BL save_psp_value");

	/*Recuperar el contexto de la siguiente tarea*/
	//1. Decidir la siguiente tarea a ser ejecutada.
	__asm volatile ("BL update_next_task");
	//2. Obtener su valor PSP pasado.
	__asm volatile ("BL get_psp_value");
	//3. Usar el valor PSP para recuperar SF2(R4 a R11).
	__asm volatile ("LDMIA R0!,{R4-R11}");
	//4. Actualizar PSP y salga.
	__asm volatile ("MRS R0,PSP");
	__asm volatile ("POP {LR}");

	__asm volatile ("BX LR");
}

void update_global_tick_count(void){
	g_tick_count++;
}

void unblock_tasks(void){
	for(int i = 0; i < MAX_TASKS; i++){
		if(user_tasks[i].current_state != TASK_READY_STATE){
			if(user_tasks[i].block_count == g_tick_count){
				user_tasks[i].current_state = TASK_READY_STATE;
			}
		}
	}
}

void SysTick_Handler(void){
	uint32_t *pICSR = (uint32_t*)0xE000ED04;

	update_global_tick_count();
	unblock_tasks();
	//Poner pendiente la excepción PendSV
	*pICSR |= (1 << 28);
}
