/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

void delay(void){
	for(uint32_t i = 0; i < 300000; i++);
}

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void)
{
	uint32_t volatile *const pClkCtrlReg 	= (uint32_t*) (0x40023800 + 0x30);
	uint32_t volatile *const pPullupDownReg	= (uint32_t*) (0x40020800 + 0x0C);
	uint32_t volatile *const pGPIOCModeReg 	= (uint32_t*) 0x40020800;
	uint32_t volatile *const pInputDataReg	= (uint32_t*) (0x40020800 + 0x10);
	uint32_t volatile *const pOutputDataReg = (uint32_t*) (0x40020800 + 0x14);

	//1.Habilitar el periferico clock  del GPIOC
	*pClkCtrlReg |= (1 << 2);

	//2.Configurar PD0,PD1,PD2,PD3 como salida (renglones)
	*pGPIOCModeReg &= ~(0xFF);
	*pGPIOCModeReg |= 0x55;

	//3.Configurar PD8,PD9,PD10,PD11 como entradas (columnas)
	*pGPIOCModeReg &= ~(0xFF << 16);

	//4.Habilitar resistencias internas de pull-up para PD8,PD9,PD10,PD11
	*pPullupDownReg &= ~(0xFF << 16);
	*pPullupDownReg |= (0x55 << 16);

	while(1){
		//Hacer todos los renglones HIGH
		*pOutputDataReg |= 0x0F;

		//Hacer R1 LOW (PD0)
		*pOutputDataReg &= ~(1 << 0);

		//Escanear las columnas
		//Cheaquear C1(PD8) si esta en alto o bajo
		if(!(*pInputDataReg & (1 << 8))){
			//La tecla es presionada
			delay();
			printf("1\n");
		}

		//Cheaquear C2(PD9) si esta en alto o bajo
		if(!(*pInputDataReg & (1 << 9))){
			//La tecla es presionada
			delay();
			printf("2\n");
		}


		//Cheaquear C3(PD10) si esta en alto o bajo
		if(!(*pInputDataReg & (1 << 10))){
			//La tecla es presionada
			delay();
			printf("3\n");
		}

		//Cheaquear C4(PD11) si esta en alto o bajo
		if(!(*pInputDataReg & (1 << 11))){
			//La tecla es presionada
			delay();
			printf("A\n");
		}


		//Hacemos todos los renglones HIGH
		*pOutputDataReg |= 0x0F;

		//Hacemos R2 LOW(PD1)
		*pOutputDataReg &= ~(1 << 1);

		//Escanear las columnas
		//Cheaquear C1(PD8) si esta en alto o bajo
		if(!(*pInputDataReg & (1 << 8))){
			//La tecla es presionada
			delay();
			printf("4\n");
		}

		//Cheaquear C2(PD9) si esta en alto o bajo
		if(!(*pInputDataReg & (1 << 9))){
			//La tecla es presionada
			delay();
			printf("5\n");
		}

		//Cheaquear C3(PD10) si esta en alto o bajo
		if(!(*pInputDataReg & (1 << 10))){
			//La tecla es presionada
			delay();
			printf("6\n");
		}

		//Cheaquear C4(PD11) si esta en alto o bajo
		if(!(*pInputDataReg & (1 << 11))){
			//La tecla es presionada
			delay();
			printf("B\n");
		}


		//Hacemos todos los renglones HIGH
		*pOutputDataReg |= 0x0F;

		//Hacemos R3 LOW(PD2)
		*pOutputDataReg &= ~(1 << 2);

		//Escanear las columnas
		//Cheaquear C1(PD8) si esta en alto o bajo
		if(!(*pInputDataReg & (1 << 8))){
			//La tecla es presionada
			delay();
			printf("7\n");
		}

		//Cheaquear C2(PD9) si esta en alto o bajo
		if(!(*pInputDataReg & (1 << 9))){
			//La tecla es presionada
			delay();
			printf("8\n");
		}

		//Cheaquear C3(PD10) si esta en alto o bajo
		if(!(*pInputDataReg & (1 << 10))){
			//La tecla es presionada
			delay();
			printf("9\n");
		}

		//Cheaquear C4(PD11) si esta en alto o bajo
		if(!(*pInputDataReg & (1 << 11))){
			//La tecla es presionada
			delay();
			printf("C\n");
		}

		//Hacemos todos los renglones HIGH
		*pOutputDataReg |= 0x0F;

		//Hacemos R3 LOW(PD2)
		*pOutputDataReg &= ~(1 << 2);

		//Escanear las columnas
		//Cheaquear C1(PD8) si esta en alto o bajo
		if(!(*pInputDataReg & (1 << 8))){
			//La tecla es presionada
			delay();
			printf("7\n");
		}

		//Cheaquear C2(PD9) si esta en alto o bajo
		if(!(*pInputDataReg & (1 << 9))){
			//La tecla es presionada
			delay();
			printf("8\n");
		}

		//Cheaquear C3(PD10) si esta en alto o bajo
		if(!(*pInputDataReg & (1 << 10))){
			//La tecla es presionada
			delay();
			printf("9\n");
		}

		//Cheaquear C4(PD11) si esta en alto o bajo
		if(!(*pInputDataReg & (1 << 11))){
			//La tecla es presionada
			delay();
			printf("D\n");
		}

		//Hacemos todos los renglones HIGH
		*pOutputDataReg |= 0x0F;

		//Hacemos R4 LOW(PD3)
		*pOutputDataReg &= ~(1 << 3);

		//Escanear las columnas
		//Cheaquear C1(PD8) si esta en alto o bajo
		if(!(*pInputDataReg & (1 << 8))){
			//La tecla es presionada
			delay();
			printf("*\n");
		}

		//Cheaquear C2(PD9) si esta en alto o bajo
		if(!(*pInputDataReg & (1 << 9))){
			//La tecla es presionada
			delay();
			printf("0\n");
		}

		//Cheaquear C3(PD10) si esta en alto o bajo
		if(!(*pInputDataReg & (1 << 10))){
			//La tecla es presionada
			delay();
			printf("#\n");
		}

		//Cheaquear C4(PD11) si esta en alto o bajo
		if(!(*pInputDataReg & (1 << 11))){
			//La tecla es presionada
			delay();
			printf("D\n");
		}

	}
}
